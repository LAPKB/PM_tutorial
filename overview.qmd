---
title: "Overview"
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, echo=FALSE, eval=TRUE, message=FALSE}
library(Pmetrics)
library(gt)

r_help <- function(pkg, name) {
    glue::glue("[`{name}`](https://rdrr.io/pkg/{pkg}/man/{name}.html)")
}

gh_help <- function(name) {
    glue::glue("[`{name}`](https://lapkb.github.io/Pmetrics/reference/{name}.html)")
}


custom_table <- function(tab){
  #system.file("extData", tab, package = "Pmetrics") %>%
    read.csv(file.path("Data",tab), na.strings = ".") %>% gt() %>%
    tab_style(
      style = list(
        cell_fill(color = "black"),
        cell_text(color = "white", weight = "bold")
      ),
      locations = cells_column_labels(everything())
    )
}

pmetrics <- function(){
    knitr::asis_output("[Pmetrics]{style=\"color: #841010; font-family: 'Arial', Arial, sans-serif; font-weight: 900;\"}")
}

```

This chapter provides an overview of the architecture of the `r pmetrics()` package, including its
main software engines, control functions, and other functions for data manipulation,
model selection, diagnostics, and plotting.


## R6 architecture

**As of v. 2.0**, `r pmetrics()` uses an "R6" architecture less dependent on
reading and writing files, preserving hard drive space and speeding execution, 
since file I/O is slow. The goal is to simplfy work within a session by 
eliminating the need to repeatedly copy and paste files from one folder to the next
whenever a new fit is executed. Storing critical objects in memory means they
can be used without accessing files. 

However, data and model files are still used for longer term storage
and preserving work from one session to another. The format of those files,
both data and model, will be familiar to long term Pmetrics users.

Data files are generally .csv and the format is detailed in the chapter on [data](data.qmd).
A model can be read from a text file or can be defined directly in R.
The easiest way to accomplish this is with our model builder app. Whether choosing
to define models in R, with the builder app, or in a .txt file, details can be 
found in [models](models.html).

## Software engines ‚öôÔ∏è

There are three main software engines that `r pmetrics()` controls currently.

<!-- * **IT2B** is the ITerative 2-stage Bayesian parametric population PK modeling -->

<!-- program. It is generally used to estimate parameter ranges to pass to -->

<!-- NPAG. It will estimate values for population model parameters under the -->

<!-- assumption that the underlying distributions of those values are normal -->

<!-- or transformed to normal, e.g. log normal. -->

-   **NPAG** is the Non-parametric Adaptive Grid software. It will create a non-parametric population model consisting of discrete support points, each with a set of estimates for all parameters in the model plus an associated probability (weight) of that set of estimates. There can be at most one point for each subject in the study population. There is no need for any assumption about the underlying distribution of model parameter values.

-   **NPOD** is the Non-parametric Optimal Design software. Like NPAG, it will create a non-parametric population model consisting of discrete support points, each with a set of estimates for all parameters in the model plus an associated probability (weight) of that set of estimates. While NPAG searches parameter hyperspace randomly, NPOD uses likelihood gradients to search systematically. This usually results in faster convergence, but currently, NPOD is more likely to get stuck in a "local" minimum of the likelihood surface, i.e. it has a higher chance of not finding the globally optimal support points. NPOD is under active development.

-   The **Simulator** is a semi-parametric Monte Carlo simulation software program that can use the output of NPAG of NPOD to build randomly generated response profiles (e.g. time-concentration curves) for a given population model, parameter estimates, and data input. Simulation from a non-parametric joint density model, i.e. NPAG output, is possible, with each point serving as the mean of a multivariate normal distribution, weighted according to the weight of the point. The covariance matrix of the entire set of support points is divided equally among the points for the purposes of simulation.

## Rust as the backend

**As of v. 3.0**, `r pmetrics()` uses Rust for the core of the package and no longer
uses Fortran. This is for several reasons, including the fact that Rust is a modern
programming language that is more efficient and easier to maintain than Fortran.
Rust is memory safe, which means that it prevents common programming errors that can lead to
memory leaks and crashes. This makes it a more reliable choice for high-performance computing tasks.
Additionally, Rust has a growing ecosystem of libraries and tools that make it easier to work with
data and perform complex computations and a more flexible choice for a wide range of applications.

## Model fitting üéõÔ∏è

`r pmetrics()` uses `r gh_help("PM_data")` to create data objects and `r gh_help("PM_model")` to create model objects. When a model is created, it is compiled and ready to be combined with the data and parameters within the model's `$fit()` method, generating probability distributions for primary model parameters. `PM_data` and `PM_model` objects and their methods are extensively documented within R by using the `help(command)` or `?command` syntax and in subsequent chapters here.

The `$fit()` method replaces these Legacy functions: `ITrun`, `ERRrun`, `NPrun`.

Invoking the simulator in R6 becomes a method attached to `PM_result` objects or by using `PM_sim$new()` for models, parameter value probability distributions and template data not derived from a previous fit, e.g. when lifted from an article.

Once a `PM_model` object is compiled, combine it with a data file, and fit the model to the data using the `$fit()` method as we saw in the [Workflow](workflow.qmd) chapter.

```{r echo=T, eval=FALSE, label=fit-method}
run1 <- mod1$fit(data, ...) #... are options listed in ?PM_model for the $fit method

```


### Simulation üìà

For the Simulator, the `$sim` method for a `PM_result` object will execute the program directly within R and return a `PM_sim` object.

```{r echo=T, eval=FALSE, label=sim-method}
run1 <- PM_load(1)
sim1 <- run1$sim(data = "new.csv") # uses the model and parameter joint density from run1, but replaces the data with new.csv
```

The first line loads previous results of run 1 into a `PM_result` object called **run1**. The second line uses the model and prior in run1 with new data template. `sim1` is a `r gh_help("PM_sim")` object.

An equivalent method is to create a new `PM_sim` is directly with `PM_sim$new()`. It also returns a `PM_sim()` object, i.e. there is no longer any need to run the Legacy function `SIMparse`. Creating simulations this way allows total freedom with respect to the model, the prior, and the data template.

```{r echo=T, eval=FALSE, label=sim-new}
sim1 <- PM_sim$new(poppar = list(...), model = "model.txt", data = "new.csv")
```

See [simulation](simulation.qmd) for details on specifying `poppar` this way.

The simulation results are returned automatically to the object assigned to contain the output of the simulation, e.g. `sim1` below.

```{r echo=T, eval=FALSE, label=sim-result}
sim1 <- PM_result$sim(...)
```

As mentioned above, there is no longer any need to use the Legacy `SIMparse` function, because the both the `SIMrun` and `SIMparse` Legacy functions are combined within the `$sim()` method for `PM_result` objects or the `PM_sim$new()` method.

### Saving üíæ

The Pmetrics R6 objects `PM_data`, `PM_result`, `PM_sim`, `PM_valid`, and `PM_pta` all have a `$save()` method. This method saves the object to the hard drive in the current working directory by default. The format is **.rds** which is a binary format used by R to save individual objects. The purpose of the `$save()` method is to enable retrieval of the object at a later time.

### Loading üìÇ

After a successful model fit, `PM_load()` creates a `PM_result` object rather than loading run results into the current environment and suffixed with the run number as for Legacy `r pmetrics()`, e.g., op.1, final.1, etc. are no longer are created.

```{r echo=T, eval=FALSE, label=load-pmresult}
run1 <- PM_load(1)
run1$op$plot()
```

To load previously saved .rds ojbects, for  `PM_sim`, `PM_valid`, and `PM_pta`, use the `$new()` method and provide the full or relative path (if not in the working directory) and name of the .rds file created by the corresponding `$save()` method.

```{r echo=T, eval=FALSE, label=load-pmsim}
sim1$save("sim.rds")
# come back another time and do this
sim1 <- PM_sim$new("sim.rds")
```

### Report generation üìÑ

The `r gh_help("PM_report")` function is automatically run at the end of a successful run, and it will generate an HTML page with summaries of the run, as well as the .Rdata files and other objects. The default browser will be automatically launched for viewing of the HTML report page. You can also regenerate the report at any time by calling the `$report()` method on a `PM_result` object.
```{r echo=T, eval=FALSE, label=report-method}
run1 <- PM_load(1)
run1$report() # regenerates the report
```


## Other functions

Within Pmetrics there are also functions to manipulate data.csv files and process and plot extracted data.

### Data manipulation

Comparison between the current and the Legacy methods are shown for education.

```{r echo=F, eval=TRUE, label=custom-table}
custom_table("RLcomp_data.csv")
```

### Model selection and diagnostics

Comparison between the current and the Legacy methods are shown for education.

```{r echo=F, eval=TRUE, label=custom-table-model}
custom_table("RLcomp_valid.csv")
```

### Other functions

Comparison between the current and the Legacy methods are shown for education.

```{r echo=F, eval=TRUE, label=custom-table-other}
custom_table("RLcomp_other.csv")
```

<!-- * Process data: `makeAUC`, `makeCov`, `makeCycle`, `makeFinal`, `makeOP`, `makePTA`, -->

<!-- `makeErrorPoly` -->

<!-- * Plot data: `plot.PMcov`, `plot.PMcycle`, `plot.PMfinal`, `plot.PMmatrix`, -->

<!-- `plot.PMop`,`plot.PMsim`, `plot.PMvalid`, `plot.PMpta` -->

<!-- * Pmetrics function defaults: `setPMoptions`, `getPMoptions` -->

Again, all functions have extensive help files and examples which can be examined in R by using the `help(command)` or `?command` syntax.